!! JAVASCRIPT IS A SYNCHRONOUS SINGLE THREADED LANGUAGE !!

npm install -D parcel ---> "-D" means dev dependancy i.e. ye sirf development env mai required hai prod env mai nhi package.
parcel ----> Bundler for npm (Other EG: webpack)
(^)caret and (~)tilde ---> In package.json ---> so what it means is : caret is used for minor version upgrade of the package installed and
                                                tilde is used for major version upgrade if any in future.... Caret is prefered.

package.json ---> It's config file for npm... It keeps track of versions of packages being used in the project.
package-lock.json --> It's different from package.json.... It keeps track of all the fixed version of packages being used so that no conflict occurs in future due version upgrade.

npx --> this command is used to execute package.

#parcel
    - Dev Build
    - Local server
    - HMR = Hot Module Replacement (auto refreshing the web page when any changes made in code and saved at run time) 
    - File watching algorithm (developed in C++)
    - Caching - For Faster dev builds (it's caching in folder named .parcel-cache folder)
    - Image Optimization
    - Consistent Hashing
    - Minification
    - Bundling and Compress
    - It creates different dev and prod bundles.
    - Tree Shaking (not using the unused code at the time of build)

- In package.json we have "main": "App.js", which is created by react itself, we need to remove it from there, if we need to set the entry point for our build to some other file.

- All the development builds which we are making by using npx are being stored in dist folder by parcel.

- To make production build using parcel command used : "npx parcel build index.html"
- To make development build using parcel command used : "npx parcel index.html"

-> npx is a package executor.. so when we write npx parcel index.html --> it means we are asking npx to run the package parcel and we are giving index.html as input to parcel.
-> npm is a package manager.

---> npm run start === npm start ... start is a reserved keyword by npm but for production build we need to run npm run build only. npm build will not work.

-> React.createElement --> It is a object not a html ---> when we render this object on DOM then it becomes a html not before.

!! IMPORTANT !!

-> JSX is not part of React.... It's just JSX is used as a syntax for React but they both can be used independently also.

-> JSX is not HTML in JS.... JSX is HTML like syntax but not HTML.

-----------------------------------------------------------------------------------------------------------------------
-> Transpiler -> converts source code from one programming lang to another... SO JS Engine can not understand JSX but still it is
                rendering on our DOM . The reason is : PARCEL(Bundler)...... So inside parcel we have "Babel" which is Transpiling our jsx code to js behind the scene so that our JS Engine can understand/render it.

-> We use Babel with React to transpile the JSX code into simple React functions that can be understood by browsers.

-> React.createElement ==>  It gives a React ELement(which is a JS object) ==> Post Rendering on DOM it becomes HTML Element.

-> JSX (It is transcompiled by babel before it reaches the JS Engine).

-> JSX is transcompiled into React Element which is a JS object and which then post rendering on DOM get's converted to HTML.
 
-> Optional Chaining is used to prevent null pointer exception. If any of the above expression is null 
   then the whole expression will be null. If all are not null then it will return the value.
    Eg: resInfo?.cards[0]?.card?.card?.info

-------------------------------------------------------------------------------------------------------------------------------

-> Functional Component is a JS function which returns a JSX object.

-> Component Composition : (Usage of one component inside other component) 
            const Heading2 = ()=>(
                 <div id="container2">
                    <Heading1 />
                    <h1 class="head">Namaste React</h1>
                </div>
            );

!! IMPORTANT !!
-> We just need to use "{}" curly braces if we need to write js/react element inside our html in functional component. Eg:

                            const num = 1000;
                            const Heading2 = ()=>(
                                <div id="container2">
                                    {num}
                                    <h1 class="head">Namaste React</h1>
                                </div>
                            );

-> Injection Attacks taken care by JSX
-> Injection attacks are when an attacker includes  malicious code within user input fields, and then submits those inputs to vulnerable systems. 
-> Cross site scripting  attacks prevented by JSX itself.

==================================================================================================================================================================

-> Props = It is just a JS object which is passed as Argument to the dynamic functional components.
                               - React wraps the prop as an object and then pass it to the functional component. 
                               Eg : (props)=>{} OR WE CAN ALSO DO USING DESTRUCTURING syntax like this : ({resName,cuisine})=>{}

-> State = Data that can change over time and re-render the component if changed. 

-> Use useState hook for declaring state in  functional components. 

====================================================================================================================================================================

-> Config driven UI : So basically it is controlling how the UI looks like using data .
                        Eg: For Delhi we have different offers and similarly for Banglore we have different offers over a website.

-> Whenever using same component multiple times using map or loop or anything, always give it a key attribute.
            REASON : Because react can not identify which one to come first , second etc.. without keys. So it will re-render all the components back again if we insert a new component. 
                    So to prevent this re rendering of all the components , key attribute is important to help react understand.

-> We can also use indexes as key in above example , but it is considered a bad practice to used indexes as keys because for the case when order of items   
    change, this can negatively impact the performance .
========================================================================================

-> Two types of export : 1. Default export which is mostly used. It is used for exporting if we only have single component in a file to export.
                            Eg: export default Header;

                        2. Named export which is mostly used if we have to export multiple components in file. Also Whenever we have named exports we have to use curly braces while importing.
                           Eg: export <name of component> = in const.js file --> export const CDN_url="" etc;.... for importing : import { CDN_url } from "./utils/const";  

=================================================================================================================================================

HOOKS  -> are utility functions(helper functions) given to us by react. In simple words they are just normal js functions which perform specific tasks.
                         1. useState() : used to maintain state of a js variable dynamically with the help of virtual DOM.
                                        syntax: const [variablename, setvariablename] = useState([by default value of variable]);
                                               
                                               - setvariablename() is used to update the state of the variable.
                                               - variablename is the name of variable.

                                        - it's just a js function which takes two argument = one is variable name and other is for setting state of that variable dynamically.
                                        - it is just array destructing. use state() return two variables one is that variable name and other is setvariable one.
                                        - it is used to create local state variable inside our function, so it will only work within the function not outside of it.
                         2. useEffect() : "it is called after the component has rendered."
                                          syntax: useEffect(()=>{<code to be executed>},[<dependency array>]);
                                          - <code to be executed>(callback function) : it is a function which is executed after the component has rendered.
                                          - <dependency array> : it is an array which contains the dependency of the function which is to be executed. If the dependency changes then the function is executed again.
                                                                - if we don't pass any dependency array then the function is executed after every render.
                                                                - if we pass an empty dependency array then the function is executed only once.
                                                                - if we pass a dependency array then the function is executed only when the dependency changes.
                                         Eg Usecase : When we want to show user our static data first(html,css etc) and then the fetched data , useEffect is used.                 



-> How React makes our application Fast ? 
                -> React is good at DOM Manipulation. 
                -> Virtual DOM helps react to work fast.

-> Why do we need useState , can't we just make a variable and update it ?
                    -> we can make a variable and update it also but the main point is it wont show in our UI.
                            Reason: variable has refreshed but it has not been re rendered on our screen and that's where useState comes into picture, Virtual DOM comes into picture... It re-renders our 
                                    "component"(not all the component, just that one component where there is change) as soon as there is a change automatically.
                    -> So, we can do it without useState also but then we need to render it explicitly everytime manually, so hooks(useState) helps us here.

======================================================================================================

-> Reconciliation algorithm (React Fiber) 
-> React uses a concept called reconciliation algorithm to determine which components need to be re-rendered and 
which components don't need to be re-rendered.(Virtual DOM)

->  react-router-dom = used for routing purpose.
                     - we can define and create multiple pages with the help of this and set there routes acc to endpoints.
                     - {createBrowserRouter} = used to create routes(endpoints). 
                     - {useRouteError} = used to get the error information if any issue comes for the route.
                     - {Outlet} = used to render components based on route without re rendering other things.
                     - {Link} = we can use Link components to navigate from one page to another page without re rendering everything , it just refreshes/switches the component.

-> Dont use anchor tags in react because it will lead to whole page getting re rendered again, which is not a good thing. Better option is to use {Link} from react-router-dom 
   it does the same job but without re-rendering every thing. so much better than anchor tag.

-> 2 types of routing in web apps:
        1. Server side routing -> we made a network call with the route and the requested page is coming from the server to us. (slow process) 
        2. Client side routing -> we made a call for the page with the route to it and based on the route, the component is rendered by the client itself. We are not making any network calls here to our server.
           It has all the pages before hand, it just loads the component based on route call on the client side itself.
                               -> Client side routing is faster than server side routing.
                               -> Single Page application(SPA) are due to client side routing. 


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-> CLASS BASED COMPONENTS
    -> Similar to functional components just a few changes.
    -> syntax: class UserName extend React.component{
                    render()
                    {
                        return (
                            <div>
                                abc
                            </div>;
                        )
                    }
                }

    -> render() : it is a method which is used to render the component, similar to return which we do in functional component.
    -> constructor() : it is a method which is used to initialize the state of the component.
    -> state : it is an object which is used to store the data of the component.
            -> state is a reserved word in class based components
            !! NEVER UPDATE STATE VARIABLES DIRECTLY !!
            -> this.state = {name: "abc"};  // this is wrong way to update
            -> this.setState({name: "abc"});  // this is correct way to update

    -> props : it is an object which is used to store the data which is passed from parent
    -> super() : it is used to call the constructor of the parent class.
    -> this.props.name : it is used to access the props of the component.
    -> lifecycle methods : they are methods which are called at different stages of the component's lifecycle.

    -> If we have to pass arguments/props to our class based component we have to receive it through constructor of the class and super method.
        syntax: <UserClass name={"Tarun Dyundi"}>

                class UserClass extend React.component{
                    constructor(props)
                    {
                        super(props);
                        //state variable
                        this.state = {
                            count=0;
                        }

                        console.log(props) // it will give us argument we passed above i.e. name.
                    }

                    render()
                    {
                        return (
                            <div>
                                <h2>Count:{this.state.count}</h2>
                                <h2>{this.props.name}</h2>
                            </div>
                        )
                    }
                }

    -> Instead of using this.props.name etc every time we can also destructure our props like const { name,location } = this.props.
    -> To change the state of a variable in class based component we have to use "this.setState()" method. It is asynchronous in nature.
    -> syntax : this.setState({
                    this.state.count = this.state.count+1;
                })
    -> Whenever a class is called from an jsx code, it's instance is created and then the render method of that instance is called. 


-------------------------------------------------------------------------------------------------------------------------------------------------------------
!! Life Cycle methods !!

-> ComponentDidMount()
    -> This method is called after the component has been rendered to the DOM.
    -> It is used to perform operations that require the DOM to be available, such as setting up event
       listeners, fetching data from an API, or updating the DOM.
    -> syntax : componentDidMount()
                {
                    // code to be executed
                }
-> ComponentDidUpdate()
    -> This method is called after the component has been updated.
    -> It is used to perform operations that require the updated component, such as updating the DOM or fetching new data from an API.
    -> It is called after every update.
    -> syntax : componentDidUpdate(prevProps,prevState)
                {
                    // code to be executed
                }
-> ComponentWillUnmount()
        -> This method is called before the component is removed from the DOM.
        -> It is used to perform cleanup operations, such as removing event listeners, or
        -> releasing resources.
        -> syntax : componentWillUnmount()
            {
                // code to be executed
            }
-> ComponentWillMount()
        -> This method is called before the component is rendered to the DOM.
        -> It is used to perform operations that require the component to be in its initial state,
        -> such as setting up initial state, or fetching initial data from an API.
        -> syntax : componentWillMount()
        {
            // code to be executed
        }

-> Two phases of react lifecycle:
            1. Render Phase : It is before DOM is updated stage. In render phase react will call the methods like shouldComponentUpdate(),render(),getDerivedState, constructor() etc.
            2. Commit Phase : It is post DOM is updated by React. In commit phase react will call the methods like componentDidMount(),componentDidUpdate(),componentWillUnmount() etc.


!! REACT LIFECYCLE  

****/
---MOUNTING CYCLE BEGIN-----
    -> Constructor(with default data)
    -> Render Method(with default data)
                -><HTML context>
      ---DOM UPDATE---
    -> ComponentDidMount
                -> API call
                -> setState
---MOUNTING CYCLE COMPLETE-----
---UPDATING CYCLE BEGIN-------
    -> Render MEthod(with api data, which we got from above)
                -> HTML context
        ---DOM UPDATE---
    ->componentDidUpdate
---UPDATING CYCLE END-------
    (if we go to some other page/component)
----UNMOUNT CYCLE BEGIN----
-> componentWillUnmount
----UNMOUNT CYCLE END----
****/

!! NOTE : Never ever try to code by comparing react's class based component's lifecycle methods with functional components way of working.

 Why component unmounting is required ?
    -> So the issue with single page architecture(SPA) is that if we are doing anything inside our componentDidMount and we move to some other component
        then also it will keep on running in background. So for cleanup of component we do unmounting when using class based components.
        
-> In functional components we don't need to do unmounting because we are not using lifecycle methods like componentDidMount() etc.
   We are using hooks like useEffect() etc. which automatically takes care of cleanup of component when we move to some other component.

-> ComponentDidMount,ComponentDidUpdate etc works like a epoll_wait i.e. it will keep on running continously post the page is rendered , till the time there are changes occurring within them.

-> 



